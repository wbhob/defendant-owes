{"dependencies":[{"name":"../utils/deprecate","loc":{"line":1,"column":26}},{"name":"../utils/is-array","loc":{"line":2,"column":20}},{"name":"../create/local","loc":{"line":3,"column":28}},{"name":"../create/valid","loc":{"line":4,"column":30}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.prototypeMax = exports.prototypeMin = undefined;\nexports.min = min;\nexports.max = max;\n\nvar _deprecate = require(\"../utils/deprecate\");\n\nvar _isArray = require(\"../utils/is-array\");\n\nvar _isArray2 = _interopRequireDefault(_isArray);\n\nvar _local = require(\"../create/local\");\n\nvar _valid = require(\"../create/valid\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar prototypeMin = exports.prototypeMin = (0, _deprecate.deprecate)('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {\n  var other = _local.createLocal.apply(null, arguments);\n  if (this.isValid() && other.isValid()) {\n    return other < this ? this : other;\n  } else {\n    return (0, _valid.createInvalid)();\n  }\n});\n\nvar prototypeMax = exports.prototypeMax = (0, _deprecate.deprecate)('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {\n  var other = _local.createLocal.apply(null, arguments);\n  if (this.isValid() && other.isValid()) {\n    return other > this ? this : other;\n  } else {\n    return (0, _valid.createInvalid)();\n  }\n});\n\n// Pick a moment m from moments so that m[fn](other) is true for all\n// other. This relies on the function fn to be transitive.\n//\n// moments should either be an array of moment objects or an array, whose\n// first element is an array of moment objects.\nfunction pickBy(fn, moments) {\n  var res, i;\n  if (moments.length === 1 && (0, _isArray2.default)(moments[0])) {\n    moments = moments[0];\n  }\n  if (!moments.length) {\n    return (0, _local.createLocal)();\n  }\n  res = moments[0];\n  for (i = 1; i < moments.length; ++i) {\n    if (!moments[i].isValid() || moments[i][fn](res)) {\n      res = moments[i];\n    }\n  }\n  return res;\n}\n\n// TODO: Use [].sort instead?\nfunction min() {\n  var args = [].slice.call(arguments, 0);\n\n  return pickBy('isBefore', args);\n}\n\nfunction max() {\n  var args = [].slice.call(arguments, 0);\n\n  return pickBy('isAfter', args);\n}"},"hash":"abd8d9805a4878a5cf23d43d0094c8c8"}